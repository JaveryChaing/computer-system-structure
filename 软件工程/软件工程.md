## 软件工程

> 软件：程序+数据+文档
>
> 1. 软件：完成预定功能的可执行指令序列
> 2. 数据：程序能处理的信息
> 3. 文档：开发，使用和维护程序相关的资料
>
> 软件工程要素：过程+方法+工具
>
> 1. 方法：完成软件各项任务的技术方法
> 1. 工具：支持方法的环境
> 1. 过程：获得高质量软件需要完成的一系列任务框架
>
> 
>
> 可行性分析任务：短时间内以最小的代价判断问题是否能解决
> 
> 可行性研究：从技术，经济及社会环境论证软件的可行性
>
> - 技术可行性：在现有资源（软硬件，技术人员水平）下满足待开发软件的功能，性能
>- 经济可行性：开发成本与预期收益
> - 社会可行性：法律约束
>
> 

#### 软件需求与规约 SRS

> 软件需求与规约：定义了软件系统的功能和非功能需求。描述了软件的预期行为、与其他系统的交互，以及对用户和利益相关者的期望，主要目的是向开发团队传达需求，验证和验证提供基准，降低项目风险，用户和开发建立共识。
>
> 需求基本性质：必要，无歧义，可测试，可跟踪，可测量
>
> 需求分类：功能需求，非功能需求（接口，设计约束，质量属性）
>
> 需求发现方法：交谈，自创，观察，小组会讨论，提炼
>
> 需求规格说明书：
>
> 1. 目的和范围（背景，业务需求，利益，期望）
> 2. 分析（市场分析，客户调研，竞争对手分析，技术评估）
> 3. 定义（功能，约束条件）
> 4. 管理（需求变更记录，版本管控，项目计划，流程跟踪）
> 5. 验证（验证技术与方法，可交付成果审查，用户验收测试）
> 6. 附录（材料证明，相关人员联系方式，技术规格清单，财务记录）

#### 结构化方法

> **结构化方法：**用于系统收集、分析和记录软件系统的需求。有助于确保需求的完整性、一致性和可验证性
>
> - **结构化分析和设计技术（SADT）**：用于分解复杂系统并识别其组成部分及其交互
>   
>   1. 确定分析边界与目标
>   2. 绘制顶级活动框，表示系统整体目的
>   3. 分解顶级活动
>   4. 识别活动输入与输出数据
>   5. 识别活动机制与约束条件
>   6. 连接活动显示数据或控制流
>   
>   
>   
> - **数据流图（DFD）**：以图形方式表示数据在系统内流动的方式（数据源、处理过程和数据接收器），表达系统功能之间的逻辑关系
>  1. 实体：系统外部的实体，与系统交换信息（矩形表示）
>   1. 过程：对数据执行转换的活动（椭圆表示）
>   1. 数据流：在实体、过程和存储之间流动的信息（带方向的箭头）
>   1. 数据存储：用于存储数据的实体（静态数据)（双下滑线）
>   1. 层次数据流图<img src="./assets/image-20240330154629605.png" alt="image-20240330154629605" style="zoom:47%;" /> 
>   1. 校验流程图方法：输入流与输出流相等，无遗漏或重复的元素
> 
>   
>   - **数据字典**：描述系统中所有数据的详细定义
> 
>  - `=`：定义为
> 
>  - `+`：顺序
> 
>  - `|`：或者，选择
> 
>  - `{}`:重复
> 
>  - m..n：可取 m~n 中的任意值
> 
>- **数据加工描述**
> 
>  - 结构化语言：IF-THEN-ELSE-ENDIF，CASE-OF-ENDCASE，DO-WHILE-ENDDO，
> 
>  - 判定表：表头列出所有的条件组合，单元格显示操作内容 
> 
>    <img src="./assets/image-20240330161540259.png" alt="image-20240330161540259" style="zoom:57%;" /> 
> 
>
>  - 判定树：
> 
>    <img src="./assets/image-20240330161655838.png" alt="image-20240330161655838" style="zoom:50%;" /> 
> 
>
> 
>
> 
>**总体设计任务** ：定义系统整体架构和主要组件，确定系统功能和性能要求，指定系统接口和通信协议，规划系统数据结构、流和存储。
> 
>**总体设计目标**：明确系统范围和约束，定义系统边界、限制和关键假设，设计一个可扩展、灵活且可维护的系统架构，遵循已建立的标准和指导方针，确保系统的质量和兼容性。
> 
>**总体设计方法**：分解系统为可管理的模块，确定模块之间的接口和依赖关系
> 
>总体设计表达：
> 
>- 蓝图（模块化结构）：描述系统及其组件的总体结构和行为，重点关注系统的主要功能和交互
> - 层次图：图形表示，展示系统组件及其层次关系
> - HIOP：描述系统组件之间的交互和数据流（以输入，输出，处理分类实体，并用箭头指明数据流向）
> 
>总体设计步骤：任何复杂的DFD都可以转为以下基本类型
> 
>- 变换型数据流图（TDF）：外部数据经过物理输入转为系统数据，再由系统物理输出为用户使用的数据
>   - 物理输入：当前实体从外部系统获取（未转换过的数据）
>   - 逻辑输入：由系统内部转换接收的数据
> - 事务型数据流程图：描述数据加工的方式
>   1. ![image-20240330174044253](./assets/image-20240330174044253.png) 
>   2. 数据流a输入到处理节点T后，由T选定该数据在那一条路径上转换
> 
>
> 
>**模块化设计**：将软件划分若干个**高内聚低耦合**的模块
> 
>- 耦合关系（模块之间依赖关系）：引用，数据传递，控制传递
> 
>  1. **内容**
>   2. 公共
>   3. 控制
>   4. 标记（间接）
>   5. **数据**
> 
>- 内聚（模块内部依赖关系）：
> 
>  1. **功能**
>   2. 顺序（先后处理）
>   3. 通信（数据关联）
>   4. 过程
>   5. 时间
>   6. 逻辑
>   7. **偶然内聚**
> 
>
> 
>**详细设计**：将总体设计阶段产生的系统高层结构转为系统最终结构
> 
>- 结构化程序设计：顺序，选择，循环
> - 设计工具：
>   - 程序流程图：使用顺序，选择结构，循环结构方式表示算法或流程的图形（不利于全局设计，无法表示数据结构）
>   - 盒图（N-S）
>     - 顺序：<img src="./assets/image-20240330182604389.png" alt="image-20240330182604389" style="zoom:50%;" /> 
>     - 选择：<img src="./assets/image-20240330182637385.png" alt="image-20240330182637385" style="zoom:50%;" /> 
>     - 循环：<img src="./assets/image-20240330182716675.png" alt="image-20240330182716675" style="zoom:35%;" /> <img src="./assets/image-20240330182744461.png" alt="image-20240330182744461" style="zoom:35%;" /> 
>   - PAD图
>     - 顺序：![image-20240330182956580](./assets/image-20240330182956580.png) 
>     - 选择：![image-20240330183013077](./assets/image-20240330183013077.png) 
>     - 循环：![image-20240330183033351](./assets/image-20240330183033351.png) 
>     - UNTIL：![image-20240330183048661](./assets/image-20240330183048661.png) 
>     - 定义：![image-20240330183111482](./assets/image-20240330183111482.png) 
>   - 伪码（PDL）：使用人类语言表达程序
> 

#### 面向对象方法

> 面向对象分析方法主要是建立：**对象模型，动态模型，功能模型**
>
> **UML**：统一建模语言，用于可视化、规范和记录面向对象系统的一种图形语言
>
> - 描述关系
>
>   1. 关联（Association）：对象中含有其他对象属性。实线+箭头
>   2. 聚合（Aggregation）：特殊的关联关系，关联实体之间不在同一生命周期中，可以由方法注入。实线+空菱形
>   3. 依赖（Dependency）：临时关联（局部变量，入参，出参）。虚线+箭头
>   4. 组合（Component）：特殊的关联关系，关联实体在同一生命周期中。实线+实心菱形
>   5. 实现（Realization）：实现关系。虚线+空三角形
>   6. 泛化（Generaliztion）：继承关系。实线+空三角形
> - 表达事物术语
>
>   1. 类与对象
>   2. 接口
>   3. 协作
>   4. 用况
>   5. 主动类：没有外部输入的情况下自动执行操作的类（用于表示并发行为）
>   6. 构件：
>   7. 制品
> - 类图：表示静态结构模型（类，接口，关联，泛化和依赖）
> - 用例图：描述系统功能需求，表达用户与系统之间交互的序列
>   1. 关联
>   2. 泛化（实现+空心三角）
>   3. 包含（虚线+箭头）
>   4. 扩展（虚线+箭头）
>   5. <img src="./assets/image-20240404190314496.png" alt="image-20240404190314496" style="zoom:50%;" /> 
> - 状态图：描述系统或对象在不同状态下的行为
>
>   1. 状态：系统或对象在特定时间内的行为（圆角矩形表示）
>   2. 过渡：通过特定事件（信号）使状态转换
> - 时序图：用于表示一段时间内发生的事件序
>
>   1. 消息：同步（带箭头实线），异步（带箭头带箭尾实线），延迟阻塞（直线），回复消息（虚线）
>   2. 对象生命线：对象存在周期，其中矩形表示在指定时间段处于激活状态
>   3. 控制操作
>
> 
>
> **RUP：**统一过程，软件开发过程框架，提供了项目管理和软件开发的方法论（基于迭代和增量开发方法，通过需求驱动开发，定义项目中角色与其对应的活动）
>
> - 以需求为驱动
>
> - 以体系结构为中心（软件开发过程划分为多个阶段，并在每个阶段提供了一系列的最佳实践和指导）
>
> - 迭代，增量式开发
>
> - 核心工作流程
>
>   1. 需求获取
>
>      - 业务需求文档中获取候选需求
>      - 业务对象建模
>      - 转为系统功能需求（创建用例，排优先级，细化用例，创建用户界面原型）
>
>      - 用例模型结构化（用例之间关系分类）
>      - <img src="./assets/image-20240331152226320.png" alt="image-20240331152226320" style="zoom: 50%;" /> 
>      - <img src="./assets/image-20240331152313745.png" alt="image-20240331152313745" style="zoom:50%;" />  
>
>   2. 需求分析
>
>      - 分析类：定义业务行为，忽略其具体特征。
>        - 边界：定义参与者与系统的约束
>        - 实体：定义长期在系统的行为
>        - 控制：定义边界与实体状态变换
>      - <img src="./assets/image-20240331153923799.png" alt="image-20240331153923799" style="zoom:50%;" /> 
>
>   3. 设计
>
>      - <img src="./assets/image-20240331160847724.png" alt="image-20240331160847724" style="zoom:50%;" /> 
>
>   4. 实现
>
>      - <img src="./assets/image-20240331161151883.png" alt="image-20240331161151883" style="zoom:40%;" />   
>
>   5. 测试
>
>      - <img src="./assets/image-20240331161225404.png" alt="image-20240331161225404" style="zoom:50%;" /> 

#### **软件测试**

> 软件测试分类：
>
> - 静态测试：不在机器上运行，采用人工检测或计算机辅助分析
>
>   1. 代码走查，评审，桌前检查
>
> - 动态测试（运行中测试）
>
>   1. 黑盒（功能测试）
>   2. 白盒（结构测试）
>
> - 阶段性测试
>
>   1. 单元
>
>   2. 冒烟：程序更新后进行浅显测试，确保软件仍然处于基本功能状态
>
>   3. 回归：软件进行变更后，重新执行以前通过的测试用例，以确保变更没有引入新的缺陷
>
>   4. 集成：多个组件之间交互黑盒测试，验证组件之间的接口和交互是否正常工作
>
>   5. 确认：验证软件修复或修改后是否已按预期修复
>
>   6. 系统：验证系统是否符合其需求并满足用户期望
>
>      
>
> **白盒测试技术**
>
> - 路径测试：遍历程序中的所有可能执行路径来测试程序，确保程序在所有可能的情况下都能够正确执行（基于程序逻辑结构）
>   1. 路径（PX）：测试最全面
>   2. 条件组合
>   3. 分支（P2）
>   4. **语句（P1）**
>
> **黑盒测试**（基于软件约规测试）
>
> 1. 场景测试（事务流）：模拟用户操作业务进行测试
> 2. 等价：通过输入，输出内容划分等价操作
> 3. 边界：使用小于，等于，大于边界值进行测试
> 4. 因果
>    - 输入条件约束：E（互斥），I（包含），O（唯一），R（要求），M（强制屏蔽）
>      - E：a，b最多有一个成立
>      - I：a，b，c中最少有一个成立
>      - O：a，b，c中仅有一个成立
>      - R：a成立，b也成立
>      - M：a成立时，b不存在，a不成立时，b的结果不确定
>    - 输入与输出依赖关系：等，非，或，与
> 5. 决定表
> 6. 错误推测

#### 软件周期与过程

> 软件周期：
>
> 1. 定义：问题定义，可行性分析，需求分析
> 2. 开发：概要设计，详细设计，编码和测试
> 3. 维护：运行与维护
>
> 软件过程：软件开发中一系列步骤、活动和任务
>
> - 开发过程：需求分析，系统架构设计，编码，测试
> - 支持过程：问题和需求管理，分类和优先级问题，文件化和知识库管理，与其他支持团队共享信息，客户服务和沟通。
> - 组织过程：规划安排任务，评估测量，执行和控制
>
> IOS/IEC制定的软件生存周期过程
>
> - 需求分析/定义/评审/确认
> - 系统设计/设计评审
> - 编码实现/单元测试
> - 系统验证
> - 发布部署/系统交互
> - 运行维护
>
> 过程描述：围绕 目的，活动与任务，结果展开
>
> 
>
> **软件过程模型**
>
> 1. 瀑布模型：将软件划分为一系列阶段，每个阶段都依赖于前一个阶段的完成，每个阶段只进行一次，适用于需求明确且稳定的项目（项目规模较小，复杂度低），强调文档化：每个阶段完成后都有详细的文档记录，方便后期维护和追溯。不适应需求变更，忽视用户反馈。（计划，开发，运行）（结构化分析）
>
>    - 问题定义
>
>    - 可行性研究
>
>    - 软件需求分析
>
>    - 系统总体设计
>
>    - 详细设计
>
>    - 编码
>
>    - 测试
>
>    - 运行
>
>      
>
> 2. 原型模型：快速构建一个系统原型来收集和细化用户的需求和反馈，适合系统要求不明确或复杂的项目，有效降低风险，增强沟通，资源消耗，处理复杂业务存在局限性。
>
>    
>
> 3. 喷泉模型：定义一个通用的概念或接口，提供各种派生作品的基础，可重用性：抽象提供了一个可重用的基础，可以创建各种派生作品。 可扩展性：新功能或行为可以通过添加新的具体化来轻松添加到系统中。可维护性：对抽象所做的更改将自动反映在所有具体化中，从而简化维护（面向对象方法）
>
>    
>
> 4. 迭代式开发：将整个软件划分多个短周期，在每个迭代中需要完成需求分析、设计、实现、测试和评审
>    - 螺旋：瀑布，迭代，原型的结合，加入风险评估，适用大型复杂项目（复杂，成本高，时间不确定，需求变更困难）
>    - 增量：每个增量阶段都提供一个可运行的产品版本。加入优先级管理，增量之间存在依赖，影响增量的发布，增量模式适用于需求不明确、易变或者项目周期较长的情况
>    - 敏捷：灵活度高，强调高效沟通，快速反馈

#### 集成化能力成熟度模型（CMMI）

> 软件能力成熟模型：一种用于评价和改进软件组织开发过程能力的框架
>
> CMMI过程改善路径
>
> - 能力等级
>   1. 未完成：过程通常是自发的、无序的，依赖于个人的努力和技能
>   2. 已管理：将一些关键过程进行文档化，并对这些过程进行管理和控制
>   3. 已定义：建立了标准化、一致且被广泛理解的过程体系，覆盖了关键领域，形成过程资产库
>   4. 量化管理：通过量化的方法对过程性能进行严格控制，能够预测过程及效率，及时发现并解决问题
>   5. 优化：注于持续改进过程，通过创新和变革来适应业务环境的变化，持续学习和改进的文化
>
> 对应软件开发过程
>
> - 未完成：软件开发主要关注的是完成特定项目或产品的基本功能实现，满足客户需求（明确项目目标、分配资源、编写代码、进行测试、交付产品）
>
>   
>
> - 已管理：除了完成基本的功能开发，还需要对软件开发过程进行规范化的管理，确保项目的可预测性和可控性（建立基本的项目管理流程，如需求管理、配置管理、质量管理、风险管理等；制定并遵循标准的工作规程；进行定期的过程检查和控制）
>
>   
>
> - 已定义：在已管理级的基础上，进一步将软件开发过程标准化、文档化，并在整个组织范围内推广使用，确保不同项目之间的过程一致性（建立过程资产库，包括过程描述、模板、指南、工具等；实施过程培训，确保团队成员理解并遵守这些过程；进行过程审计，验证过程执行的一致性和有效性）
>
>   
>
> - 量化管理：在已定义级的基础上，通过量化手段对软件开发过程和产品质量进行度量、分析和控制，实现过程性能的持续改进（建立度量体系，选择度量指标，使用统计方法理解和控制过程变异，预测过程性能；基于度量结果进行决策，驱动过程改进）
>
> - 优化：在量化管理级的基础上，以持续改进组织的整体绩效为目标，不断寻求创新和突破，优化整个软件开发生命周期（开展过程改进研究，探索新的技术、方法和工具；建立创新文化，鼓励团队成员提出改进建议；运用先进的数据分析和建模技术，深入理解过程和产品的复杂关系，驱动组织级的变革）
>

