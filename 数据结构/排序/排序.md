## 排序

> _内排序是在整个排序过程中,待排序的所有记录全部被放置在内存中,外排序是由于排序记录个数多,不能同时放在内存中,整个排序过程需要在内存外进行数据交换_
>
> > __排序算法性能影响__
> >
> > - 时间性能
> > - 辅助空间
> > - 算法复杂度
>
> #### 冒泡排序(交换排序)
>
> > __比较两两相邻的记录的关键字,如果反序则交换,直到没有反序记录为止__
> >
> > ~~~c
> > // 自后向前扫描的冒泡排序
> > void BubbleSort(SqList * L)
> > {
> >     int i,j;
> >     status flag = true;
> >     for (i=1;i<L->length && flag;i++) // 两两比较循环
> >     {
> >         flag = false;
> >         for(j=L->length-1;i>=i;j--) // 倒叙遍历比较
> >         {
> >          if(L->r[j]>L->r[j+1])
> >          {
> >              swap(L,j,j+1);
> >              flag =true;
> >          }
> >         }
> >     }
> > }
> > ~~~
>
> #### 选择排序(Simple Selection Sort)
>
> > __通过n-i次关键字比较,从n-i+1个记录中选出最小的记录,并和第i个记录交换__(从未排序的数列中遍历一位元素与已排序最大元素__比较交换位置__)
> >
> > ~~~c
> > void SelectSort(SqList *L)
> > {
> >     int i,j.min;
> >     for(i=1;i<L->length;i++) // 循环数组
> >     {
> >         min = i;            // 哨兵下标
> >         for(j=i+1;j<=L->length;j++)
> >         {
> >             if(L->r[min]>L->r[j])
> >                 min = j;
> >         }
> >         if(i!=min)
> >             swap(L,i,min);
> >     }
> > }
> > ~~~
> >
> > ![image-20211006182126524](image-20211006182126524.png) 
> >
> > 选择排序性能优于冒泡排序
>
> 
>
> #### 插入排序
>
> > __将一个接入插入到已经排好序的有序数列中,从而得到一个新的有序数列(相邻比较交换)__
> >
> > ~~~c
> > void InsertSort(SqList * L)
> > {
> >     int i,j;
> >     for(i=2;i<=L->length;i++)
> >     {
> >         if(L->r[i] < L->[i-1]) // 需将L->r[i]插入有序子表
> >         {
> >             L->r[0] = L->r[i]; // 设置哨兵
> >             for(j=i-1;L->r[j]>L->r[0];j--)
> >                 L->r[j+1]=L->r[j]; // 记录后移
> >             L->r[j+1]=L->r[0];  
> >         }
> >     }
> > }
> > ~~~
> >
> > > 性能优于选择排序
>
> #### 希尔排序(分组插入排序) TODO
>
> > ![image-20211006184807747](image-20211006184807747.png) 
>
> #### 堆排序
>
> > __堆排序(Heap Sort)将待排序的序列构成一个大顶堆,此时,序列的最大值是根结点,移走后,再次进行堆排序选出一个最大根结点取走__
> >
> > 

