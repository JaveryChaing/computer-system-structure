## 排序

> _内排序是在整个排序过程中,待排序的所有记录全部被放置在内存中,外排序是由于排序记录个数多,不能同时放在内存中,整个排序过程需要在内存外进行数据交换_
>
> > __排序算法性能影响__
> >
> > - 时间性能
> > - 辅助空间
> > - 算法复杂度
>
> #### 冒泡排序(交换排序)
>
> > __比较两两相邻的记录的关键字,如果反序则交换,直到没有反序记录为止__
> >
> > ~~~c
> >  // 自后向前扫描的冒泡排序
> > Void BubbleSort(SqList *L)
> > {
> >   int i,j,flag;
> >   for(i=1; i<L->length; i++){
> >     flag=0;
> >     for(j=L->length-1;j>=i+1;j--)
> >     {
> >       if(L->r[j]<r[j-1]){
> >        swap(L,j,j+1);
> >        flag = 1;
> >      }  
> >      if(flag==0) return
> >   }
> >  }
> > }
> > 
> >~~~
>
> #### 选择排序
>
> > __每一趟在待排序的记录中筛选出记录最小的数据,依次存放在以排好序的列表中__
>
> - 直接选择排序
>
>   > _每次从待排序中选择最小记录,将该记录与该区中第一个记录交换位置_
>   >
>
> #### 插入排序
>
> > __将待排序的记录存在R中,每次从未排序的集合中取出一个值放在已排序的合适位置__
> >
> > ~~~c
> > void InsertSort(SeqList R, int n)
> > {
> >     int i,j;
> >     for(i=2;i<=n;i++)
> >         if(R[i].key<R[i-1].key){
> >             R[0] = R[i]; //设置哨兵 循环终止条件
> >             for(j=i-1;R[0].key<R[j].key;j--) 
> >                 R[j+1] = R[j];
> >                 R[j+1] = R[0];
> >         }
> > }
> > ~~~
> >
> > 