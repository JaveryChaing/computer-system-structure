## Schema与数据类型优化

> #### 数据类型选择
>
> - 满足业务最小的数据类型
>
> - 避免NULL设计
>
> - 使用整形代替字符集
>
> - DATETIME 与TIMESAMP 区别
>
>   > | DATETIME                                               | TIMESAMP                                                |
>   > | ------------------------------------------------------ | ------------------------------------------------------- |
>   > | 8字节                                                  | 4字节                                                   |
>   > | 不存在时区问题                                         | 以世间标准时间存储,查询时转换客户端当前时区进行返回     |
>   > | 1000-01-01 00:00:00.000000 ~9999-12-31 23:59:59.999999 | 1970-01-01 00:00:01.000000 ~ 2038-01-19 03:14:07.999999 |
>
> - 整数类型
>
>   > TINYINT SMALLINT MEDIUMINT  INT BIGINT  8,16,24,32,64位存储空间  范围值 $-2^{N-1}到2^{N-1}-1$
>   >
>   > UNSIGNED 不存在负数部分,使得正数存储返回提高一倍
>   >
>   > **对于指定整数类型宽度没有意义**  int(1) 与 int(20) 相同
>
> - 实数类型
>
>   > FLOAT,DOUBLE,DECIMAL(**精确小数计算,最多65个数字**),计算大量数字时使用整数和倍率进行小数转换
>
> - 字符串类型(与存储引擎相关)
>
>   > VARCHAR 与CHAR
>   >
>   > > VARCHAR可变长字符串
>   > >
>   > > CHAR 定长字符串(等长情况下性能高于VARCHAR)
>   >
>   > BINARY 与 VARBINARY 存储**二进制字符串**
>   >
>   > 
>   >
>   > BOLB与TEXT类型 
>   >
>   > > BOLE无排序规则 与字符集   TEXT存在排序规则与字符集
>   >
>   > 使用枚举(ENUM)代替字符串类型
>   
> - 位数据类型
>
>   > BIT 可以在一列中存储多个 true/false值 BIT最长64位
>   >
>   > SET 存储多个true/false 
>
> - 选择标识符(identifier)
>
> #### **Sehema设计**
>
> > - 避免过多的列(销耗查询性能)
> > - 关联过多
> >
> > **范式和反范式**
> >
> > > 1. 确保每列数据原子性
> > > 2. 确保表中的每一列都与主键相关
> > > 3. 确保每列都和主键直接相关(不存在间接相关属性)
> >
> > **缓存表和汇总表**
> >
> > > 汇总表通常使用group by 对元素数据进行统计汇总
> > >
> > > 数据查询慢而需要经常使用的数据进行优化
> >
> > **计数器表**
> >
> > > 使用多行数据分组统计累加值(避免全局互斥锁)提高事务并发性
> > >
> > > ~~~sql
> > > update hit_counter set cnt = cnt +1 where slot = RAND()*100;
> > > select sum(cnt) from hit_counter;
> > > ~~~
> >
> > 

## MYSQL高级特性

> - **分区表**
>
>   > *分区的主要目的将数据按照一个较粗的颗粒度存在不同表中，mysql表数据文件分为三部分，frm存放表结构，myd存放数据，myi存放索引，分区表文件使用#进行扩充，*
>   >
>   > - 一张表最多1024个分区
>   > - 分区表中不允许使用外键
>   > - 主键/索引分区必须包含全部(不支持部分分区)
>   > - 超大数据进行分区查询(数据量超大 B-Tree 无法进行优化)
>   > - 
>   >
>
> - **分区表类型**
>
>   > - RANGE(范围)分区  基于属于一个给定连续区间的列值，把多行分配给分区
>   > - LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择
>   > - HASH分区
>   > - KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多
>   >
>   > ~~~sql
>   > create table sales (
>   > order_date datetime not null,
>   >  -- Other columns omitted
>   > ) engine = InnoDB PARTITION BY RANGE( YEAR(order_date))(
>   >  PARTITION p_2010 values less then (2010),
>   >      PARTITION p_2011 values less then (2011),
>   >      PARTITION p_2012 values less then (2012),
>   >       PARTITION p_catchall values less then MAXVALUE
>   > )
>   > ~~~
>   >
>   > - 索引列与分区类不匹配,会导致查询无法通过分区过滤(通过索引进行查询)
>
> #### **全文索引**
>
> > *针对于模糊查询索引(非精准值查询)*
> >
> > - MATCH() 返回关键字匹配相关度(浮点值）
>
> 

