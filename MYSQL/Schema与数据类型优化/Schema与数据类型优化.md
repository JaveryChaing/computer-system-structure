## Schema与数据类型优化

> #### 数据类型选择
>
> - 满足业务最小的数据类型
>
> - 避免NULL设计
>
> - 使用整形代替字符集
>
> - DATETIME 与TIMESAMP 区别
>
>   > | DATETIME                                               | TIMESAMP                                                |
>   > | ------------------------------------------------------ | ------------------------------------------------------- |
>   > | 8字节                                                  | 4字节                                                   |
>   > | 不存在时区问题                                         | 以世间标准时间存储,查询时转换客户端当前时区进行返回     |
>   > | 1000-01-01 00:00:00.000000 ~9999-12-31 23:59:59.999999 | 1970-01-01 00:00:01.000000 ~ 2038-01-19 03:14:07.999999 |
>
> - 整数类型
>
>   > TINYINT SMALLINT MEDIUMINT  INT BIGINT  8,16,24,32,64位存储空间  范围值 $-2^{N-1}到2^{N-1}-1$
>   >
>   > UNSIGNED 不存在负数部分,使得正数存储返回提高一倍
>   >
>   > **对于指定整数类型宽度没有意义**  int(1) 与 int(20) 相同
>
> - 实数类型
>
>   > FLOAT,DOUBLE,DECIMAL(**精确小数计算,最多65个数字**),计算大量数字时使用整数和倍率进行小数转换
>
> - 字符串类型(与存储引擎相关)
>
>   > VARCHAR 与CHAR
>   >
>   > > VARCHAR可变长字符串
>   > >
>   > > CHAR 定长字符串(等长情况下性能高于VARCHAR)
>   >
>   > BINARY 与 VARBINARY 存储**二进制字符串**
>   >
>   > 
>   >
>   > BOLB与TEXT类型 
>   >
>   > > BOLE无排序规则 与字符集   TEXT存在排序规则与字符集
>   >
>   > 使用枚举(ENUM)代替字符串类型
>   
> - 位数据类型
>
>   > BIT 可以在一列中存储多个 true/false值 BIT最长64位
>   >
>   > SET 存储多个true/false 
>
> - 选择标识符(identifier)
>
> #### **Sehema设计**
>
> > - 避免过多的列(销耗查询性能)
> > - 关联过多
> >
> > **范式和反范式**
> >
> > > 1. 确保每列数据原子性
> > > 2. 确保表中的每一列都与主键相关
> > > 3. 确保每列都和主键直接相关(不存在间接相关属性)
> >
> > **缓存表和汇总表**
> >
> > > 汇总表通常使用group by 对元素数据进行统计汇总
> > >
> > > 数据查询慢而需要经常使用的数据进行优化
> >
> > **计数器表**
> >
> > > 使用多行数据分组统计累加值(避免全局互斥锁)提高事务并发性
> > >
> > > ~~~sql
> > > update hit_counter set cnt = cnt +1 where slot = RAND()*100;
> > > select sum(cnt) from hit_counter;
> > > ~~~
> >
> > 

## MYSQL高级特性

> - **分区表**
>
>   > *分区的主要目的将数据按照一个较粗的颗粒度存在不同表中，mysql表数据文件分为三部分，frm存放表结构，myd存放数据，myi存放索引，分区表文件使用#进行扩充，*
>   >
>   > - 一张表最多1024个分区
>   > - 分区表中不允许使用外键
>   > - 主键/索引分区必须包含全部(不支持部分分区)
>   > - 超大数据进行分区查询(数据量超大 B-Tree 无法进行优化)
>   > - 
>   >
>
> - **分区表类型**
>
>   > - RANGE(范围)分区  基于属于一个给定连续区间的列值，把多行分配给分区
>   > - LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择
>   > - HASH分区
>   > - KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多
>   >
>   > ~~~sql
>   > create table sales (
>   > order_date datetime not null,
>   >  -- Other columns omitted
>   > ) engine = InnoDB PARTITION BY RANGE( YEAR(order_date))(
>   >  PARTITION p_2010 values less then (2010),
>   >      PARTITION p_2011 values less then (2011),
>   >      PARTITION p_2012 values less then (2012),
>   >       PARTITION p_catchall values less then MAXVALUE
>   > )
>   > ~~~
>   >
>   > - 索引列与分区类不匹配,会导致查询无法通过分区过滤(通过索引进行查询)
>
> #### **全文索引**
>
> > *针对于模糊查询索引(非精准值查询)*
> >
> > - MATCH() 返回关键字匹配相关度(浮点值）
>
> 

> - **并发控制**
>
>   - 读写锁
>
>     > 共享锁(shared lock) 读锁
>     >
>     > 排他锁(exclusive lock) 写锁
>
>   - 锁粒度(基于MYSQL引擎选择)
>
>     > 行锁(row lock) => InnoDB  XtraDB 
>     >
>     > > 最大程度支持并发
>     >
>     > 表锁(table lock)
>
> - **事务** 
>
>   > - 原子(atomicity)  
>   > - 一致(consistency) 
>   > - 隔离(isolation) 
>   > - 持久性(durability)
>   >
>   > 
>   >
>   > **隔离级别**
>   >
>   > - READ UNCOMMITTED
>   > - READ COMMITED 
>   > - REPEATABLE READ 可重复读 (在事务中语句查询的数据**内容一致**，幻读：一个事务在执行中读取到另一个事务**插入**已提交的数据，读取2次数据返回不一样）
>   > - SERIALIZABLE （避免幻读情况，**可以接受无并发场景**）
>   >
>   > ![image-20211209170510875](image-20211209170510875.png) 
>   >
>   > - 死锁
>   >
>   >   > 多个事务加锁在同一个资源上,并**相互请求锁定**对方占用的资源
>   >   >
>   >   > InnoDB处理死锁将持有少数行级排他锁进行事务回滚
>   >
>   > - 事务日志
>   >
>   >   > 先将操作的记录写在硬盘事务日志中(顺序I/O),在将内存中的数据进行更新在持久化到硬盘上
>   >
>   > - MYSQL中事务(InnoDB ，NDBCluster，XtraDB,PDXT)
>   >
>   >   > ~~~sql
>   >   > -- 1表示开启  0 表示关闭
>   >   > show variables like 'AUTOCOMMIT'
>   >   > set autocommit = 1
>   >   > -- 配置当前会话隔离级别
>   >   > set session transaction isolation level read commited
>   >   > ~~~
>   >
>   > - LOCK/UNLOCK TABLES  在服务层进行加锁 与存储引擎无关
>
>   **多版本并发控制(MVCC)** 基于行锁控制	
>
> > MVCC通过数据时间点快照实现（根据事务开始时间，每个事务对同一张表，**同一时刻看到的数据可能不一样**）
> >
> > InnoDB 的MVCC实现过程
> >
> > - 每行记录存在两个隐藏列，包含行的创建时间(系统版本号)，和删除时间(系统版本号)
> > - 每开始一个新事务,系统版本号自动递增
> >
> > InnoDB  repeatable read 隔离级别下 
> >
> > 查找时
> >
> > - InnoDB只查找版本**早于当前事务版本**的数据行（确保事务开始前存在，事务自身插入的行）
> > - 行的删除版本未定义，或大于当前事务的版本号（确保事务读取到的行在**事务开始之前未被删除**） 
> >
> > 插入时
> >
> > - InnoDB为新插入的每一行保存当前系统版本号作为行号
> >
> > 删除时
> >
> > - InnoDB为删除的行每行保存当前系统版本号作为删除标识
> >
> > 修改时
> >
> > - 将当前行号保存到删除标识，在将当前系统号保存到行号
> >
> > MVCC只在REPEATABLE READ和READ COMMITTED 两个级别下兼容
