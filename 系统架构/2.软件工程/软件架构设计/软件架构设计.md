## **软件架构设计**

> **架构模型**
>
> 1. 结构模式：通过结构来反映系统的重要语义，内容研究结构模型的核心是架构描述语言
>
> 2. 框架模式：以一些特殊的问题为目标建立只针对和适应该问题的结构
>
> 3. 动态模型
>
> 4. 过程模型：过程模型研究构造系统的步骤和过程。因而结构是遵循某些过程脚本 的结果
>
> 5. 功能模型：为架构由一组功能构件按层次组成，且下层向上层提供服务
>
> 6. 4+1模型：
>
>    ![image-20230901210149344](image-20230901210149344.png) 
>
>    逻辑视图：支持系统功能需求，系统分解成一系列的功能抽象（保持单一，内聚的对象模型贯彻系统）
>
>    开发视图：要侧重于软件模块的组织和管理（需要考虑软件的容易性、软件的重用和软件的通用性）
>
>    进程视图：侧重于系统运行特征（系统可用性，性能，分布，容错，集成）
>
>    物理视图：软件适配硬件（解决系统拓扑结 构、系统安装、通信等问题）
>
>    场景：重要系统活动的抽象
>
> **软件属性**
>
> - 质量特性
>
>   1. 安全
>
>      > ![image-20230901220135161](image-20230901220135161.png) 
>      >
>      > 抵抗攻击：用户身份验证，授权，数据脱敏，校验。限制暴露信息，限制访问，使用防火墙，DMZ策略（隔离区，类似于外网与内网之间缓存环境）
>      >
>      > 检测攻击：比较通信模式与历史访问基线
>
>   2. 易用
>
>      > ![image-20230901222320218](image-20230901222320218.png) 
>
>   3. 可伸缩
>
>   4. 与其他系统交换和相互调度难度
>
>   5. 性能
>
>      > 资源需求：提高算法效率，减少计算开销（可修改性与性能之间权衡，减少不必要代理构件）
>      >
>      > 资源管理：引入并发。维持数据或计算的多个副本，减少服务器计算压力。增加服务器资源
>      >
>      > 资源仲裁：使用合适的调度策略（FIFO，固定优先调度，动态优先调度）
>
>   6. 可靠（持续可用）
>
>      > ![image-20230901214221860](image-20230901214221860.png) 
>      >
>      > 可用性技术：阻止错误发展成故障，把错误影响限制在一定范围内
>      >
>      > - 错误检测：心跳消息
>      > - 错误恢复：表决器（选举），主动冗余（热重启，热备份），被动冗余（备用构件从最新同步点接替主 构件的工作）
>      > - 错误预防：重启，事务控制
>
>   7. 容错性（鲁棒）：非正常环境下运行能力
>
>   8. 易理解
>
>   9. 可扩展
>
>   10. 可重用
>
>   11. 可测试
>
>       > ![image-20230901222244721](image-20230901222244721.png) 
>
>   12. 可维护
>
>       > 局部化修改：预期的变更限制在一定的范围，维持语义一致性
>       >
>       > **防止连锁反应**：信息隐藏（设置公有，私有接口），维持现有接口（不在原接口上更改），限制通信路径，使用仲裁者方式把服务间语义隔离
>       >
>       > 热部署：系统具备在运行时进行绑定并允许非开发人员进行修改
>       >
>       > 配置文件：在启动时设置参数
>       >
>       > 多态
>       >
>       > 构件更换：运行载入时绑定
>
>   13. 可移植
>
>       ![image-20230901214113774](image-20230901214113774.png) 
>

#### **软件测试**

> 为了发现错误而执行程序的过程
>
> **测试活动**
>
> - 制定系统测试计划：测试的内容、进度安排、测试所需的环境和条件（包括设备、 被测项目、人员等）
> - 测试大纲：针对系统功能或特性完成的基本测试项目和测试完成的标准
> - 生成测试用例：被测项目、输入数据、测试过程、预期输出结果
> - 缺陷管理与改错，生成测试报告（测试进行概要说明，列出测试的结论，指出缺陷和错误）
>
> 
>
> **软件测试原则**
>
> 1. 应尽早并不断地进行测试
> 2. 测试包含不合理输入条件
> 3. 修改后应进行回归测试
> 4. 所有的测试都应追溯到用户需求
> 5. 穷举测试是不可能的
> 6. 严格按照测试计划来进行
> 7. 妥善保存测试计划、测试用例
>
> ![image-20230906223456792](image-20230906223456792.png) 
>
> - 单元测试：对系统最小模块进行测试，有开发人员执行
> - 集成测试：子功能组合测试
> - 冒烟测试：对修改功能进行多次测试
> - 确认测试（合格测试）：检验软件是否符合用户的需求
> - 系统测试：在实际运行环境下进行测试（要完成功能测试、性能测试、恢复测试、安全测试、强度测试）
> - 验收测试：检验系统说明书的各项功能与性能是否实现和满足要求
> - 回归测试：测试软件变更之后，变更部分的正确性对变更需求的符合性
> - α与β测试：由用户/内部用户模拟实际操作环境下进行的受控测试
> - 白盒测试：根据内部结构和逻辑来设计测试用例，对程序路径和过程进行测试
>   - 语句覆盖SC：使得使被测试程序中每条语句至少执行一次
>   - 判断覆盖DC：使程序中的每个判定至少都执行一次
> - 黑盒测试：基于产品功能规格说明书，从用户角度针对产品特定的功能和特性进行验证活动，确认每 功能是否得到完整实现
>   - 等价类划分：

