## 存储管理

- #### **概述**

  > 物理地址：内存中实际存储单元地址
  >
  > 逻辑地址：（相对地址）：指令地址
  >
  > 编译：将告警语言翻译为机器语言
  >
  > 装载：将程序从外存载入内存中运行
  >
  > 装载方式：
  >
  > - 绝对装入（编译时产生物理地址的指令）
  > - 静态重定位（依据当前内存情况，将**相对地址重定位到物理地址**，作业进入内存，在运行期间不能移动）
  > - **动态重定位**（将地址转换推迟到程序执行时进行，CPU进行转换）
  >
  > 程序运行步骤：
  >
  > 1. 编辑源代码文件
  > 2. 编译
  > 3. 链接
  > 4. 装入

- #### **内存管理**

  > 地址转换（装载方式）
  >
  > 分配与回收
  >
  > 内存扩充
  >
  > 内存共享
  >
  > 内存保护（进程不越界访问内存）
  >
  > > **设置上下限寄存器**
  > >
  > > **利用重定位寄存器，界地址寄存器判断**

- #### **内存空间扩充**

  >  _解决程序大小超过物理内存总和问题_
  >
  > - **覆盖技术** 
  >
  >   > 将程序分为多个段(模块)，将需要常住内存的段放入固定区，将不常用的段放在覆盖区，**需要运行时调入内存**
  >   >
  >   > <img src="image-20220406233046238.png" alt="image-20220406233046238" style="zoom:67%;" />  
  >   >
  >   > *必须由程序员声明覆盖结构，操作系统自动完成覆盖，对用户不透明**
  >
  > - **交换技术** 
  >
  >   > 内存空间不足时，将某些进程暂时换出外存，把外存中具备允许条件的进程换入内存（内存调度）
  >   >

#### **内存空间分配与回收**

> - **连续分配管理方式（进程使用连续的空间）**
>
>   > **单一连续分配**：系统内存分为用户区和系统区，用户进程独占用户区且只能有一道程序运行，无内存碎片，存储器利用低。
>   >
>   > 
>   >
>   > **固定分区分配：** 等额，非等额切分内存，并建立分区说明表（分区大小，起始位置，状态）
>   >
>   > 
>   >
>   > **动态分区分配：** 可变分区分配，不会预先划分内存空间，根据进程的大小动态建立分区（分区的大小正好合适进程的需要，无内部碎片）
>   >
>   > ​	内部碎片：分配给进程的内存区域中存在部分没用上
>   >
>   > ​	外部碎片：内存中某些空闲的分区太小难以使用
>   >
>   >  
>   >
>   >  **动态分区分配算法：** _解决多个空闲分区满足需求是，选择那个分区进行分配_
>   >
>   > 1. 首次适应算法（按**低地址排序**查询，找到第一个满足大小的空闲区）
>   >
>   > 2. 最佳适应算法（按**容量递增**链接，每次分配内存时按内存大小顺序查找空闲分区链）
>   >
>   >    > 会产生很多外部碎片
>   >
>   > 3. 最大适应算法（按**容量递减**链接，每次分配内存时查找第一个满足要求的分区）
>   >
>   >    > 存在大进程无法使用内存空间
>   >
>   > 4. 邻近适应算法（按低地址排序，每次分配内存时从上次分配地址查找）
>   >
>   > <img src="image-20220407215829781.png" alt="image-20220407215829781" style="zoom:80%;" />  
>
> **非连续分配管理方式（进程使用离散的空间）**
>
>   > **分页存储管理方式：** _将内存空间分为一个大小相等的分区_
>   >
>   > > **页：** 将程序的逻辑空间分为一些**大小相同的片段**
>   > >
>   > > **物理块：** 内存空间分为与**页大小相同**的片段
>   > >
>   > > **页表：**__记录页到物理块的关系映射集合__，**每一个进程都提供一个页表放在PCB中**
>   > >
>   > > **动态地址转变**
>   > >
>   > > >地址结构：逻辑地址包含页号p，页内位移量v（页内地址）
>   > > >
>   > > >​                   物理地址分解为物理块号b，和物理块内位移量v
>   > > >
>   > > >p = 逻辑地址 / **页面长度**
>   > > >
>   > > >v = 逻辑地址 % **页面长度**
>   > >
>   > > **基本地址变换机构**
>   > >
>   > > > PTR：页表寄存器（**存放页表在内存中启起始地址F和页表长度M**）
>   > > >
>   > > > 页表项：记录页与内存块的映射关系
>   > > >
>   > > > 页表长度：页表记录长度
>   > > >
>   > > > 页表项长度：页表项占用的存储空间
>   > > >
>   > > > ---
>   > > >
>   > > > **逻辑地址A到物理地址E转变过程** (L为页面长度)
>   > > >
>   > > > 1. 计算逻辑地址页号p和页内偏移量v
>   > > > 2. 比较页号p和**页表长度M**，P>=M 则越界中断
>   > > > 3. 页表中页号p对应的**页表项地址=起始地址F + 页号P * 页表项长度**，通过页表项获取内存块号b
>   > > > 4. E = b * L +v
>   > > >
>   > > >  **确定页面长度，逻辑地址**，系统可以自动计算出页号，页内偏移量
>   > > >
>   > > > 
>   > >
>   > > **块表(TLB)**   _联想寄存器，加快对**页表项**访问速度_
>   > >
>   > > > *通过加快页表的访问，以加速地址转换的过程，与此对应，内存中的页表称为慢表*
>   > > >
>   > > > 最近使用过的页表项会放入块表（充当缓存）
>   > > >
>   > > > ---
>   > > >
>   > > > 时间局部性：程序中某条指令在短时间内多次访问
>   > > >
>   > > > 空间局部性：连续访问内存地址相邻的指令
>   > >
>   > > **两级页表**
>   > >
>   > > > 单级页表问题
>   > > >
>   > > > 1. 页表必须连续存放，因此页表很大时，需要占用多个连续的物理块
>   > > > 2. 没有必要让整个页表常住内存
>   > > >
>   > > > ---
>   > > >
>   > > > 页目录表：将之前的页表以一定范围进行分组
>   > > >
>   > > > <img src="image-20220408002224252.png" alt="image-20220408002224252" style="zoom:80%;" />  
>   > > >
>   > > > 采用多级页表机制，则各级页表大小不能超过一个页面
>   >
>   > ---
>   >
>   > **分段存储管理方式**
>   >
>   > > 分段：按照**程序自身逻辑关系**划分为若干个段，每个段都有段名，**每段从0开始编址**，分配内存时以段位单位进行分配，**每个段在内存中占据连续空间，各段之间可以不相邻**
>   > >
>   > > ![image-20220408004053336](image-20220408004053336.png) 
>   > >
>   > > **段表：** 记录段号，段长，基址映射关系集合
>   >
>   > ---
>   >
>   > 分页与分段对比
>   >
>   > 1. 页为信息的物理单位，分页主要是实现内存的离散分配，提高内存利用率，是操作系统进行控制，对用户不可见
>   > 2. 段是信息的逻辑单位，分段主要目的是为更好满足用户需求
>

#### **虚拟内存**

> *内存空间的扩充*
>
> ![image-20220408005512841](image-20220408005512841.png) 
>
>  传统存储管理方式：（内存不够问题）
>
> - 一次性：作业必须一次性全部装入内存后运行
> - 驻留性：作业被装入内存，就会一直驻留在内存中

