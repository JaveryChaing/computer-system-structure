## **死锁**

- **死锁定义**

  > 在多道程序系统中，一组进程中的一个**进程均无限等待**被该组另一个进程**占用且不会释放的资源**，死锁发生后进程将一致等待下去，除非有来自死锁外的进程进行干预

  

- **死锁产生原因**

  > - 竞争资源
  >   1. 可剥夺资源（内存，处理机）
  >   2. 不可剥夺资源（不能强制收回，使用完后释放）
  >   3. 临时资源（消耗性资源）
  > - 进程推进不合理（请求和释放的顺序不当）

  

- **死锁产生必要条件**

  > 1. 互斥（资源排他使用，导致其他进程等待该资源，区别与同步）
  > 2. **不可剥夺**（进程在使用资源时加锁，不能被其他进程获取锁，只能进程自愿释放锁）
  > 3. 请求和保持（一个进程因请求资源而阻塞时，对已获得的资源保持不放）
  > 4. 循环等待（若干进程之间形成一种头尾相接的循环等待资源关系）

  

- #### **预防死锁**(预先设置)

  > *设置限制条件破坏死锁产生的4个必要条件，防止死锁*
  >
  > 
  >
  > 1. 摒弃请求和保持条件
  >
  >    > 系统要求一次性申请进程所需的全部资源（防止运行时请求资源），等待期间线程不占有任何资源
  >    >
  >    > ---
  >    >
  >    >  缺点：
  >    >
  >    > - 造成严重的资源浪费，恶化系统资源占用率
  >    > - 进程延迟运行，资源长期被其他进程占有，阻塞其他进程运行
  >
  > 2. 摒弃不剥夺条件
  >
  >    > 若进程申请新资源不能立即获取，则必须释放已有的资源，在重新申请（资源短暂释放，剥夺）
  >    >
  >    > ---
  >    >
  >    > 缺点：
  >    >
  >    > - 反复申请和释放资源。进程效率不高，延迟进程周转时间，降低系统吞吐量
  >
  > 3. 摒弃循环等待条件
  >
  >    > 所有资源按类型进行线性排队，进程对资源的请求严格安装资源顺序申请
  >    >
  >    > ---
  >    >
  >    > 缺点：
  >    >
  >    > - 系统中各种资源类型分配序号必须稳定
  >    > - 程序使用资源与系统规定资源顺序不一致，造成资源浪费

  

- #### **死锁避免**  （运行避免）

  > *资源动态分配过程中，使用某种方法**防止**系统进入不安全状态*
  >
  > 1. 安全与不安全状态
  >
  >    > - 安全状态（系统能按进程顺序来为每个进程分配所需资源，使资源不冲突）
  >    > - 不安全状态（不按照安全顺序分配资源）
  >
  > 2. 银行家算法(Dijkstra)
  >
  >    > **所需的数据结构**
  >    >
  >    > 1. 可利用资源向量（Available）使用数组代替，元素代表**一类可利用资源数目**，初始值为系统中改类的全部可用资源数目  记为 Available[j] = k 表示系统中有$R_j$类资源k个
  >    > 2. 分配矩阵（Allocation) 定义系统中**每一类资源当前已分配给每一个进程的资源数**，Allocation（i，j）=k，表示进程i当前已分得$R_j$类资源的数目为k个
  >    > 3. 需求矩阵Need，表示每一个进程尚需要各类资源数 Need（i，j）=k 表示进程i需要分得$R_j$类资源的数目为k个，方能完成任务
  >    >
  >    > $$
  >    > Need(i,j) = Max(i,j) - Allocation(i,j)
  >    > $$
  >    >
  >    > **算法步骤**
  >    >
  >    > 设$Request_i$是进程$P_i$的请求向量，如果$Request_i[j]=k$，表示进程$P_i$请求k个$R_j$类型的资源。
  >    >
  >    > 1. 如果$Request_i$ <=$ Need_i$ 则转向步骤(2) ，否则认为出错，因为它所需要的资源数已经成超过它宣布的最大值
  >    >
  >    > 2. 如果$Request_i$ <= Available 则转向步骤（3），否则表示尚无足够资源，$P_i$必须等待
  >    >
  >    > 3. 系统尝试把要去的资源分配给进程$P_i$，并修改数值
  >    >    $$
  >    >    Available = Available- Request；\\
  >    >     Allocation = Allocation + Request;\\
  >    >     Need = Need - Request;
  >    >    $$
  >    >
  >    > 4. 系统执行安全性算法，检测系统是否处于安全状态（若安全，资源分配给进程P_i 完成本次分配，否则等待）

  

- #### **检查死锁与解除死锁**

  > *及时检测死锁的发送。采取适当的措施，从系统中消除死锁发生*
  >
  > **解除死锁方法**
  >
  > 1. 剥夺资源（使用其他进程剥夺死锁占有的进程）
  > 2. 撤销进程（将死锁的进程按照逻辑逐个撤销）

  

  


