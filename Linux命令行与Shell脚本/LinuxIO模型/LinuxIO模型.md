## Linux IO模型

- #### sync，fsync，fdatasync

  > *当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作，延迟写，延迟写减少磁盘读写次数，降低文件内容更新速度*
  >
  > sync：将修改过的缓存块排入写队列（非阻塞）
  >
  > fsync：等待写磁盘操作结束后返回（阻塞）
  >
  > fdatasync：只更新数据，不改变文件属性
  
- #### 缓存IO

  > - 缓存IO（数据从磁盘先通过DMA copy到内核空间，再从内核空间通过cpu copy到用户空间）
  >
  >   > 由操作系统进行IO操作，保护系统安全，减少IO读盘次数，提高系统读写性能。需要内核目态与管态中断切换，对CPU和内存开销大
  >
  > - 直接IO（数据从磁盘通过DMA copy到用户程序）
  >
  >   > 主要减少从内核缓冲区到用户程序 缓存的数据复制
  >
  > - 网络IO
  >
  >   > 1. 操作系统读盘加载内核页缓存中
  >   > 2. 应用将数据从内核缓存复制到应用的缓存中
  >   > 3. 应用将数据写回内核的Socket缓存中
  >   > 4. 操作系统将数据从Socket缓存区复制到网卡缓存，然后将其通过网络发出

- #### 同步，异步，阻塞IO，非阻塞IO

  > 同步：进程需等待本次任务结束后才能执行下一次任务
  >
  > 异步：不需要等待本次执行结果，等待结果异步通知进程
  >
  > 阻塞IO：执行进程等待IO过程
  >
  > 非阻塞IO：执行进程发起IO后，无需等待，返回时，可能没数据
  >
  > 异步实现方式：多线程，回调，Promise，Reactor
  >
  > ---
  >
  > **同步阻塞I/O:** 应用调用系统函数(目态到管态)导致用户应用阻塞等待系统函数返回（**进程上下文切换消耗**）
  >
  > **同步非阻塞I/O:** 由用户程序主动判断IO是否结束（用户进程可以执行其他任务）**导致整体数据吞吐量的降低**。
  >
  > **复用I/O模型(异步非阻塞I/O)：**用户程序发起IO后，由内核通知应用程序来处理IO
  >
  > ---
  >
  > **Reactor**：反应器设计模型（多路分配策略，由一个非阻塞线程接收所有请求，派发给相应线程执行，**异步非阻塞IO模型**）
  >
  > - Handle句柄：标识socket文件描述符
  >
  > - Synchronous Event Demultiplexer同步事件多路分解器：由操作系统内核函数实现（监听句柄集合上发送的事件）
  >
  >   > select：轮询检查fd是否发送变化
  >   >
  >   > epoll，kqueue：注册回调函数，当文件发生改变时执行回调
  >
  > - Event Handler：事件处理接口
  >
  > - Concrete Event：实现应用程序事件处理逻辑（实现Event Handler接口）
  >
  > - **Initiation Dispatcher 事件容器**：Synchronous Event Demultiplexer与Event Handler适配器，系统事件阻塞等待返回时，回调相应的Event Handler使其处于就绪状态（非执行），同时提供Event Handler以注册、移除等
  >
  > - **Reactor反应器**：供应用程序注册和删除关注的事件句柄，循环EventHandler容器是否存在就绪事件，有就绪事件到来时，分发事件到之前注册的（Event Handler）回调函数上处理
  >
  > 
  >
  > **Reactor执行顺序**
  >
  > 1. program通过Reactor将事件（转换）注册到Event Handler 容器（异步）
  > 2. Synchronous Event Demultiplexer监听到事件已完成，回调相应的Event Handler使其处于就绪状态
  > 3. Reactor循环容器判断是否存在就绪事件，Reactor将就绪事件分发到之前注册的**回调函数中处理**
  >
  >   <img src="img\image-20221207163806028.png" alt="image-20221207163806028" style="zoom: 67%;" /> 
  >
  > 
  >
  > Reactor：实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。
  >
  > ---
  >
  > **Proactor模式**  由设备实现非阻塞IO操作
  >
  > *Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即 可，操作系统会读取缓存区或者写入缓存区到真正的IO设备*
  >
  > 

