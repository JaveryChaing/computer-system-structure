## 原型模式

> __用原型实例指定创建对象的种类,并通过拷贝这些原型创造新的对象__
>
> Java中使用原型模式通过复写clone方法完成(以二进制流方式进行拷贝,重新分配内存块)
>
> #### 深拷贝与浅拷贝
>
> > ~~~java
> > class Thing implements Cloneable {
> >     private List<String> arrList = new ArrayList<>();
> >     @Override
> >     protected Object clone() {
> >         Thing thing = null;
> >         try {
> >             thing = (Thing) super.clone();
> >             // 对引用对象重新clone 完成深拷贝
> >            // cloneThing.arrList = (ArrayList<String>) this.arrList.clone();
> >         } catch (CloneNotSupportedException e) {
> >             e.printStackTrace();
> >         }
> >         return thing;
> >     }
> >     public void setValue(String value) {
> >         this.arrList.add(value);
> >     }
> >     public List<String> getValue() {
> >         return this.arrList;
> >     }
> > }
> > ~~~
> >
> > __两个对象共享了一个私有变量为浅拷贝(引用)__
> >
> > _在java类中基本数据类型和String可以进行深拷贝,引用数据类型为浅拷贝_
> >
> > 
>
> 原型模式应用
>
> - 性能比直接new好
> - 逃避构造方法的约束
>
> 使用场景
>
> - 类初始化时候需要消化非常多的资源
> - 数据准备
> - 一个对象多个修改者(通常与工厂方法模式出现)
>
> 

