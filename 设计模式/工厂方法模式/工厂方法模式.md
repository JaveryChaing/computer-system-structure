## 工厂方法模式 

> __定义一个用于创建对象的接口,让子类决定实例化哪一个类,工厂方法使用一个类实例化延迟到其他子类__
>
> _在工厂模式中,抽象产品类Product负责定义产品的共性,实现对事物最抽象的定义,Creator为抽象创建类,具体创建产品类是由实现的工厂ConcreteCreator完成_
>
> ![image-20211018115148144](image-20211018115148144.png) 
>
> - 降低模块之间耦合
> - 扩展性非常优秀(只需要增加实现类完成任意扩展)
> - 屏蔽实现类(通过接口定义,完成具体实现)
>
> JDBC连接数据库(ORACLE与MYSQL驱动切换)
>
> >  ![image-20211017232456637](image-20211017232456637.png) 
>
> > ~~~java
> > // 抽象人类创建工厂
> > public abstract class AbstractHumanFactory {
> >     public abstract <T extends Human> T createHuman(Class<T> c);
> > }
> > ~~~
> >
> > - 抽象工厂类(使用泛型限制createHuman入参)
> >
> > ~~~ java
> > // 工厂创建类
> > public class HumanFactory extends AbstractHumanFactory {
> >     @Override
> >     public <T extends Human> T createHuman(Class<T> c) {
> >         Human human = null;
> >         try {
> >             human = (Human) Class.forName(c.getName()).newInstance();
> >         } catch (InstantiationException e) {
> >             e.printStackTrace();
> >         } catch (IllegalAccessException e) {
> >             e.printStackTrace();
> >         } catch (ClassNotFoundException e) {
> >             e.printStackTrace();
> >         }
> >         return (T) human;
> >     }
> > }
> > ~~~
> >
> > - 实现抽象类中创建方法
> >
> > > 通过工厂类创建实体
> > >
> > > ~~~java
> > > public static void main(String[] args) {
> > >         // 声明创造类实体
> > >         AbstractHumanFactory humanFactory = new HumanFactory();
> > > 
> > >         WhiteHuman WhiteHuman = humanFactory.createHuman(WhiteHuman.class);
> > > 
> > >         BlackHuman BlackHuman = humanFactory.createHuman(BlackHuman.class);
> > > 
> > >         YellowHum human = humanFactory.createHuman(YellowHum.class);
> > >         
> > >     }
> > > ~~~
> >

## 简单工厂

> 简单工厂模式最大优点在于工厂类中包含必要的逻辑判断
>
> 工厂方法模式:定义一个用于创建对象的接口,子类决定实例化哪一个类(一个类的实例化延迟到其子类)
>
> 

